---
title: "算法思想"
description: "作为 iOS 开发者，面试中的算法考察往往不仅是看你能不能写出代码，更是看你的逻辑严密性、对性能的敏感度以及解决复杂问题的抽象能力。要做到举一反三，核心在于从刷题转向模式识别."
publishedAt: "2025-12-25"
tags:
  - "算法"
  - "iOS"
---

## 1. 建立“模式仓库” (Pattern Recognition)

不要把每一道题看作孤立的点，而要看作某种**通用模式**的实例。绝大多数面试题都可以归纳为以下几类：

- **双指针 (Two Pointers)：** 适用于有序数组、寻找对子、反转、去重。
    
- **滑动窗口 (Sliding Window)：** 解决“子串”、“子数组”类问题的利器。
    
- **快慢指针 (Fast & Slow Pointers)：** 专门对付链表（环检测、找中点）。
    
- **二分搜索 (Binary Search)：** 只要看到“有序”或者“寻找最优解且具有单调性”，第一反应就是二分。
    
- **DFS / BFS：** 树的遍历、图的搜索、路径寻找。iOS 中的 View Hierarchy 遍历就是典型应用。
    
- **动态规划 (DP)：** 解决“求最值”、“求方案数”且存在重叠子问题的情况。核心是写出状态转移方程：$dp[i] = f(dp[i-1], ...)$。

## 2. 理解数据结构与算法的“天性”

算法思维的本质是：**根据数据的物理存储特性，选择最合适的逻辑操作。**

|**数据结构**|**物理特性**|**擅长算法 / 思维**|
|---|---|---|
|**Array**|连续内存，下标访问 $O(1)$|排序、双指针、二分搜索|
|**LinkList**|离散内存，指针连接|递归、快慢指针、反转|
|**Stack/Queue**|先进后出 / 先进先出|递归转迭代、BFS 层次遍历|
|**Hash Table**|空间换时间，$O(1)$ 查找|计数、去重、缓存 (LRU)|
|**Tree/Graph**|非线性分支结构|DFS、回溯 (Backtracking)|

## 3. iOS 开发中的算法映射

为了让思维更具象，你可以尝试将算法与 iOS 实际场景关联：

- **LRU Cache：** `NSCache` 的底层逻辑。结合了 **Hash Map** ($O(1)$ 查找) 和 **双向链表** ($O(1)$ 更新顺序)。
    
- **Diff 算法：** `UITableView` / `UICollectionView` 的增量更新。理解编辑距离 (Edit Distance) 和动态规划。
    
- **响应链 (Responder Chain)：** 本质上是一个 **单向链表** 的回溯寻找。
    
- **View Hierarchy：** 视图树的渲染顺序（深度优先 BFS）与点击事件分发（深度优先 DFS）。
- 
## 4. 四步解题思维法 (面试实战)

当你拿到一道陌生的题时，按照这个流程思考：

1. **Clarification (明确需求)：** 询问边界条件（数组为空？有负数吗？内存限制？）。
    
2. **Brute Force (暴力破解)：** 先想出一个最直观、哪怕性能最差的解法，保证逻辑闭环。
    
3. **Optimize (优化)：** 观察重复计算。
    
    - 能不能用 **空间换时间** (Hash Table)?
        
    - 能不能利用 **有序性** (Binary Search)?
        
    - 能不能通过 **预处理** (前缀和、排序)?
        
4. **Complexity Analysis：** 始终给出时间复杂度 $O(n)$ 和空间复杂度 $O(1)$ 的分析。

