---
title: "二进制重拍"
description: "什么是二进制重拍?为什么要重拍?怎么重拍?"
publishedAt: 2025-11-19
tags:
  - "面试"
  - "iOS"
  - "技术"
---

![image.png](https://raw.githubusercontent.com/macong0420/Image/main/20251119155312782.png)


**二进制重排（Binary Reordering）** 的本质是用空间换时间，通过减少**缺页中断（Page Fault）** 的次数来加速 App 启动。

以下是为你准备的**深度技术解析**，包含底层原理、实施方案（Clang 插桩）以及面试时的回答策略。

***

### 1. 核心原理：为什么要重排？

#### 1.1 虚拟内存与分页（Virtual Memory & Paging）

iOS 系统（和其他现代 OS 一样）使用虚拟内存。

- **物理内存**：RAM，有限且昂贵。

- **虚拟内存**：每个进程认为自己拥有独立的、连续的内存空间。

- **映射关系**：系统将内存切分为一个个 **Page（页）**。在 iOS (A9 处理器以后) 上，一页的大小通常是 **16KB**。

#### 1.2 缺页中断（Page Fault）—— 性能杀手

当 App 启动时，系统并不会把整个 App 二进制文件一次性加载到 RAM 中（那样太慢且浪费）。而是\*\*“按需加载”\*\*。

- 代码执行到某个函数 funcA。

- CPU 查找 funcA 的虚拟地址，发现它对应的物理内存页**没有被加载到 RAM 中**。

- **触发 Page Fault（缺页中断）**。

- 操作系统暂停 App 线程，去磁盘（Flash Storage）把包含 funcA 的那一页数据读入 RAM，并建立映射。

- App 线程恢复执行。

**痛点**：一次 Page Fault 虽然只要几毫秒，但启动过程中如果涉及几千个函数调用，且这些函数分散在不同的页里，就会产生**成百上千次 Page Fault**。

- 计算：假设一次中断耗时 1ms，2000 次中断就是 2 秒的延迟！

#### 1.3 默认的编译链接顺序

编译器默认是按照 **Compile Sources** 中的文件顺序，以及文件内部的代码书写顺序来排列二进制符号的。

- **现状**：启动时需要的函数 A, B, C, D 可能分布在第 1, 50, 100, 200 页上。

- **后果**：为了执行这 4 个小函数，系统需要加载 4 个完整的 16KB 页面。

#### 1.4 二进制重排的目标

利用链接器（Linker）的特性，将启动期间所有执行到的函数 A, B, C, D **紧凑地排列在一起**，放到二进制文件的前面（第 1 页）。

- **结果**：加载 1 个页面就能包含所有启动函数，Page Fault 次数从 N 降为 1。

***

### 2. 技术实现：怎么做？（Clang 插桩）

实现二进制重排的关键在于：**如何精准地找到启动时刻执行了哪些函数？**

早期方案（如 Hook objc\_msgSend）只能覆盖 OC 方法，无法覆盖 C 函数、Block 和 Swift。\
**目前业界的标准解法是：Clang SanitizerCoverage 插桩。**

#### 2.1 编译期插桩 (Compile Time)

LLVM 内置了一个工具 SanitizerCoverage，它可以在编译时，在**每个函数**（包括 C/C++/Swift/OC/Block）的边缘插入一段自定义的回调代码。

**配置步骤**：\
在 Xcode 的 Build Settings -> Other C Flags 中添加：

codeBash

```
-fsanitize-coverage=func,trace-pc-guard
```

如果是 Swift 项目，还需要在 Other Swift Flags 添加 -sanitize-coverage=func and -sanitize=undefined。

#### 2.2 代码实现 (Runtime)

添加 flag 后，你需要实现两个核心回调函数。当 App 启动时，任何函数被调用，都会先跳进你实现的 guard 函数。

codeObjective-C

```
#import 
#import 

// 1. 定义原子队列，用于保存捕获到的符号地址，保证线程安全
static OSQueueHead symbolList = OS_ATOMIC_QUEUE_INIT;

// 定义节点结构体
typedef struct {
    void *pc;
    void *next;
} SymbolNode;

// 2. 初始化回调（系统自动调用，告诉你有多少个哨兵节点）
void __sanitizer_cov_trace_pc_guard_init(uint32_t *start, uint32_t *stop) {
    static uint64_t N;
    if (start == stop || *start) return;
    printf("INIT: %p %p\n", start, stop);
    for (uint32_t *x = start; x < stop; x++) {
        *x = ++N; // 给每个插桩点编号
    }
}

// 3. 核心回调：每当有函数被调用时，会先执行这里
void __sanitizer_cov_trace_pc_guard(uint32_t *guard) {
    if (!*guard) return; // 过滤掉已经记录过的，避免重复
    
    // 获取当前函数的返回地址（即调用者的内部地址）
    // __builtin_return_address(0) 是 GCC/Clang 内置函数
    void *PC = __builtin_return_address(0);
    
    // 创建节点并存入队列
    SymbolNode *node = malloc(sizeof(SymbolNode));
    *node = (SymbolNode){PC, NULL};
    
    // 入队（原子操作，线程安全）
    OSAtomicEnqueue(&symbolList, node, offsetof(SymbolNode, next));
}
```

#### 2.3 生成 Order File

在 App 启动结束（例如 viewDidAppear）时，从队列中取出所有地址，利用 dladdr 函数将地址转换为**符号名**。

codeObjective-C

```
- (void)generateOrderFile {
    NSMutableArray *symbols = [NSMutableArray array];
    while (true) {
        SymbolNode *node = OSAtomicDequeue(&symbolList, offsetof(SymbolNode, next));
        if (node == NULL) break;
        
        Dl_info info;
        dladdr(node->pc, &info);
        NSString *name = @(info.dli_sname); // 获取函数符号名
        
        // 处理 OC 方法名前的下划线等逻辑...
        // 处理 Block 和 Swift 混编的各种 Name Mangling...
        [symbols addObject:name];
    }
    
    // 倒序（因为队列是后进先出的，需要反转回调用顺序）
    NSArray *result = [[symbols reverseObjectEnumerator] allObjects];
    
    // 去重并写入 .order 文件
    NSString *orderContent = [result componentsJoinedByString:@"\n"];
    [orderContent writeToFile:filePath atomically:YES encoding:NSUTF8StringEncoding error:nil];
}
```

#### 2.4 链接器配置 (Linking)

- 拿到生成的 app.order 文件。

- 放入工程根目录。

- 在 Xcode Build Settings -> **Order File** 中配置该文件路径。

- 重新编译。Linker（ld）会读取这个文件，并强制按照文件中的顺序排列二进制段。

***

### 3. 面试官会怎么问？（实战对答）

**Q1: 你是怎么做启动优化的？**

> **A:** 我通过建立 APM 监控体系发现启动耗时主要集中在 Pre-main 阶段。除了常规的动态库治理和 +load 移除外，我引入了**二进制重排**技术。利用 Clang 的 SanitizerCoverage 进行编译期插桩，覆盖了 100% 的启动函数（包括 C/Swift/Block），生成 Order File 指导链接器重排。最终将 System Trace 中的 Page Fault 次数减少了 xx%，启动速度提升了 15%\~20%。

**Q2: 为什么不用 objc\_msgSend Hook 而要用 Clang 插桩？**

> **A:** objc\_msgSend 方案（如 fishhook）只能覆盖 Objective-C 的方法调用。但现在的项目通常是混编的，初始化流程中包含大量的 C/C++ 构造函数、C 函数调用（如 dyld 阶段的回调）以及 Swift 方法，这些通过 Runtime Hook 是拿不到的。\
> Clang 插桩是在 **IR（中间代码）** 层面插入的，它可以无视语言差异，真正做到全覆盖。

**Q3: 插桩代码对包体积和性能有影响吗？上线需要保留吗？**

> **A:** 有影响。
>
> - **性能**：每个函数调用都多了一次跳转，会变慢。
>
> - **体积**：包体积会显著增大。\
>   **所以！** 这个配置\*\*仅在开发阶段（Debug模式）\*\*用于生成 Order File。生成的 Order File 提交到仓库后，**正式发版（Release模式）时移除插桩配置（Other C Flags）**，只保留 Order File 路径配置。这样既享受了重排的优化，又不会有任何副作用。

**Q4: 怎么验证重排生效了？**

> **A:** 使用 Xcode 自带的 **Instruments - System Trace** 工具。
>
> - 对比优化前后的 Main Thread -> Virtual Memory -> File Backed Page In 次数。
>
> - 查看 Link Map 文件，确认符号的排列顺序是否与 Order File 一致。