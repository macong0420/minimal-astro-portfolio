---
title: "超强超屌的路由框架"
description: "在大型 iOS 模块化工程中，路由（Router）是解耦各个业务模块的核心基础设施。普通的 URL Router（基于字符串匹配）往往存在参数类型不安全、硬编码严重的问题，而 Protocol Router（基于协议）虽然类型安全但灵活性稍逊。"
publishedAt: 2025-11-20
tags:
  - "iOS"
  - " 开发"
---

![image.png](https://raw.githubusercontent.com/macong0420/Image/main/20251120104618310.png)


# 深入解析 LJRouter：贝壳/链家的高性能 iOS 路由框架

在大型 iOS 模块化工程中，路由（Router）是解耦各个业务模块的核心基础设施。普通的 URL Router（基于字符串匹配）往往存在参数类型不安全、硬编码严重的问题，而 Protocol Router（基于协议）虽然类型安全但灵活性稍逊。

本文将深入剖析贝壳/链家自研的 **LJRouter**，这是一个结合了 **编译期注入**、**运行时动态调用** 和 **智能参数匹配** 的高级路由框架。它不仅解决了传统路由的痛点，还引入了许多令人眼前一亮的“黑科技”。

***

## 1. 核心架构设计

`LJRouter` 的设计理念是将“页面跳转”和“功能调用”统一管理，同时保持极高的灵活性。其内部维护了两个核心的 **调用中心 (Invocation Center)**：

- **`pageInvocationCenter`**: 专门负责页面路由。目标方法必须返回一个 `UIViewController` 实例。
- **`actionInvocationCenter`**: 负责通用功能路由。可以返回任何值，或者执行一段逻辑（如弹窗、埋点、数据处理）。

这种分离设计使得路由职责更加清晰，同时也方便了后续的查找和处理逻辑。

### 1.1 双中心查找机制

当发起一个路由请求时，`LJRouter` 采用**双中心级联查找**策略：

1. 优先在 `pageInvocationCenter` 中查找匹配的 Key。
2. 如果未找到，再尝试在 `actionInvocationCenter` 中查找。

这种机制保证了页面跳转的优先级，同时也兼容了同名 Key 的不同用途（虽然不推荐这样做）。

***

## 2. 注册机制：Mach-O Section 注入黑科技

这是 `LJRouter` 最核心、最精彩的部分。不同于传统路由需要在 `load` 方法中手动注册 URL 和 Block，`LJRouter` 利用了 Clang 的 `__attribute__((section("name")))` 特性，将注册信息直接写入二进制文件的特定段中。

### 2.1 宏定义注册

开发者只需要在 

.m 文件中使用宏即可完成注册，无需在任何地方手动 import 头文件：

// 注册一个页面跳转

LJRouterRegistAction(@"user\_detail\_page", openUserDetail, UIViewController \*, (NSString \*)userId) {

```
UserDetailViewController \*vc \= \[\[UserDetailViewController alloc\] initWithUserId:userId\];

return vc;
```

}

这个宏在编译预处理阶段，会被展开为一段特殊的 C 结构体定义，并被标记写入 `__DATA` 段的 `__LJRouterUseINF` Section 中。

### 2.2 启动加载与解析

在 App 启动阶段（或首次访问路由时），`LJRouter` 会执行 `loadAndCheck` 方法：

1. **遍历 Image**: 使用 `_dyld_image_count` 和 `_dyld_get_image_header` 遍历所有加载的动态库和主程序。
2. **读取 Section**: 使用 `getsectiondata` 函数直接读取 `__LJRouterUseINF` Section 的数据。
3. **解析结构体**: 将读取到的二进制数据转换为 `LJRouterUseInfo` 结构体数组。
4. **构建索引**: 将这些信息加载到内存中的 `allKeyMethods` 字典中，建立 Key 到具体方法签名的映射。

**优点**：

- **去中心化**: 路由定义分散在各个业务模块内部，主工程无需感知。
- **零侵入**: 不需要修改 `AppDelegate` 或任何初始化代码。
- **启动性能**: 虽然需要读取 Section，但相比于执行成百上千个 `[Router registerURL:...]` 方法，直接内存映射读取的效率极高。

***

## 3. 智能参数匹配与重载

传统的 URL Router 通常只支持 Key-Value 形式的参数传递（`scheme://page?id=123`），这导致传递复杂对象（如 Model、Image）非常困难。`LJRouter` 基于 `NSInvocation` 实现了原生级别的参数传递，并支持**方法重载**。

### 3.1 参数评分机制

`LJRouter` 允许同一个 Key 注册多个不同参数列表的方法。例如：

- `open_user (NSString *id)`
- `open_user (NSString *id, NSString *source)`

当调用 `[LJRouter routerKey:@"open_user" params:@{@"id":@"1", @"source":@"push"} ...]` 时，路由内部的 `findInvocation` 方法会进行**评分匹配**：

1. 遍历该 Key 下所有注册的方法。
2. 对比传入的 `params` 字典与注册方法的参数列表。
3. **最大匹配原则**: 选择匹配参数数量最多、且定义顺序最靠前的那个方法。

### 3.2 自动类型转换

虽然核心是原生调用，但 `LJRouter` 也内置了 `LJRouterConvertManager`。如果传入参数是字符串（来自 URL Scheme），而目标参数是 `NSNumber` 或 `BOOL`，它会尝试进行安全的类型转换，增强了对 H5 调起 App 场景的兼容性。

***

## 4. 上下文注入与依赖解耦

在模块化开发中，获取当前上下文（Current Context）是一个痛点。`LJRouter` 通过 **自动参数注入** 优雅地解决了这个问题。

### 4.1 自动注入 SenderContext

如果注册的方法中包含类型为 `LJRouterSenderContext` 的参数，Router 会自动创建一个 Context 对象并注入进去。

LJRouterRegistAction(@"show\_alert", showAlert, void, (LJRouterSenderContext \*)context) {

```
// 自动获取当前的 UIViewController，无需调用方显式传递

UIViewController \*currentVC \= context.contextViewController;

\[currentVC presentViewController:...\];
```

}

`LJRouterSenderContext` 利用 Responder Chain（响应者链）机制，从原始的 `sender`（通常是一个 View）开始向上查找，直到找到 VC、Window 甚至 AppDelegate。

### 4.2 回调注入 (RouterCallback)

为了解耦“页面返回”或“数据回传”，`LJRouter` 约定了 `LJRouterCallbackBlock`。

- 如果目标 VC 实现了 `routerCallBack` 属性，Router 在创建 VC 后会自动赋值。
- 如果注册方法参数中有 `LJRouterCallbackBlock` 类型，Router 也会自动将调用方传入的 Block 注入进去。

***

## 5. 类型安全检查 (Type Safety)

动态路由最大的隐患是参数类型不匹配导致 Crash。`LJRouter` 在这方面做了极致的防御。

### 5.1 启动自检

在 Debug 模式下，`checkAllMethodTypeName` 方法会在启动时运行：

- 它会对比注册宏中声明的参数类型（如 `NSString *`）与实际 Block/方法签名中的类型。
- 如果发现不匹配，会根据 `checkPolicy` 策略，选择 **控制台报警**、**弹窗提示** 甚至 **直接断言崩溃**。

这确保了开发者在开发阶段就能发现所有的路由定义错误，而不是等到上线后用户触发 Crash。

***

## 6. 总结

`LJRouter` 是一个工业级的 iOS 路由方案，它在灵活性和安全性之间找到了完美的平衡：

- **底层技术**: 利用 Mach-O Section 注入实现分布式注册。
- **调用方式**: 基于 `NSInvocation` 实现原生调用，性能损耗极小。
- **开发体验**: 宏定义注册简单快捷，支持参数重载和自动补全。
- **稳定性**: 完备的类型检查机制杜绝了运行时类型错误。

对于致力于组件化、模块化改造的 iOS 团队来说，`LJRouter` 的设计思路非常值得深入学习和参考。